## Inspirationm
- https://azure.microsoft.com/en-us/services/key-vault/
- https://cloud.google.com/kms/
- https://www.vaultproject.io

## KeyRing
There is a single keyring (KMS supports creation of multiple keyrings, we currently don't need to provide support for it).
The idea is that keys are either generated by KMS, or provided to KMS, but they never leave KMS, so unwrapping, encrypting and decrypting secrets, happen in the KMS trusted secure env.



# APIs
## Google
- https://cloud.google.com/kms/docs/quickstart
- Create KeyRings
- Keys created in KeyRings
- Base64 encoding of requests/responses plaintext and ciphertext provided
- To encrypt/decrypt, you reference (keyring, key) 
- A key can be created with a specified rotation period, which is the time between when new key versions are generated automatically.
	A key can also be created with a specified next rotation time.
- Labels are light-weight way to group together keys that are realted or associatesd with each other, and are great for tracking items in billing.
- Storing secrets amounts to storing a secret in a Google Cloud Storage bucket encrypted at the app. layer, with an encryption key from Google KMS
	KMS doesn't directly store secrets. It can encrypt secrets thatr you store elsehere: https://cloud.google.com/kms/docs/store-secrets
	This makes sense, but it doesn't seem to be directly wrapping/unwrapping like it's mentioned in the whitepaper

## Azure
- Creating a key amounts to providing a name, attributes, and some other specifics (e.g tags)
- Getting a key returns the *public* part of a stored key. So looks like they are using PKI, that's why they are
	also offering signing and unsigning operations
- Setting a secret sets a specified key vault. The SET operation adds a secret to the Key Vault, and if a names secret 
	You set the name and the value, and it's stored. 
- Encryption amounts to encrypting something with an encryption key that is stored in a key vault. 
	The encrypt operation is only strictly necessary for symmetric keys used in Azure Vault, sicne protection with an assymetric key can be
	performed using public portion of the key. This operation is supported for asymetric keys as a convenience for callers that have
	a key-reference but do not have access to the public key material. The request contains the algorithm and the value, and the response contain the ciphertext
- Decryption decrypts a wel-formed block of ciphertext using the target encryption key and specified algorithm. It's the reverse of the ENCRYP operation, only a single
	block of data may be decrypted, and the size of this block is dependent on the target key and the algorithm to be used. It applies to asymetric and symmetric keys stored in the vault
	since it uses the PRIVATE portion of the key.
- Signing creates a signature form a sigest using the specified key. It is application to assymetric and symmetric keys stored in the vault, since this portion uses the PRIVATE portion of the key
- Verifying a signature using a specified key, is applicable to symmetirc keys stored in the vault. It is not strictly necessary for assymetric keys stored in the vault, since
	signature verification can be performed using the public portion of the key, but this op. is supported as a conveneince for callers that only have a key-reference, and not the public
	portion of the key.
- Wrapping a key swraps a symmetirc key using a specified key. It supports encryption of the symmetric key, using a key encryptionm key that has previously been stored in an Azure Kehy Vault Same rationale re:convenience as verify etc


## Vault
Secrets written to Vault are encrypted and then written to backend storage. Vault encrypts the value before it is ever handed to the storage driver.
The storage driver never sees the unencrypted value and doesn't have the means to decrypt without Vault.
```
vault write secret/hello value=world
```
This writes the pair(value=word) to the path secret/hello. It is important that path is prefixed with secret/, otherwise this wouldn't work.
The secret/ prefix is where arbitrary secrets can be read and written.

You can even write multiple pieces of data
```
vault write secret/hello value=world excited=yes
```



So Vault doesn't maintain a keyring, just a storage backend where the data are encrypted/decrypted using the wrapping key derived from the Master Key
It associates (key, value) pairs with an id (e.g secret/hello).
We are going to support that as well. See `phaistos_kms.secrets`

To read a secret
```
vault read secret/hello
```
which returns all key/values. Valut reads the data from storage and decrypts them
**IDEA**: salt the pair name with the wrapping key to create another key to lock/unlock the pair value?
Should be also be able to return those in json format

Vault supports multiple backends, not just the consul kv backend. Vault supports "mounting" backends like so
```
vault mount kv
```
By default, the mount point will be the same as the backend.
But you can also mount kv to secret/, for example. (that's how it works with those examples)

### Dynamic Secrets
Dynamic Secrets are secrets that are generated when they are accessed, and aren't statically written. The power of the Dynamic Secrets is that they
simply don't exist before they are read, so there is no risk of someone stealing them, or another client using the same secrets.
And because Vault as built-in revocation mechanisms, the dynamic secret can be revoked right after use, minimizing the amount of time the secret existed.

#### EXAMPLE
```
vault mount aws
```
With the AWS backend mounted, the first step is to configure it with the AWS credentials that will be used to crete the other credentials. For now, use
the root keys for your AWS account.
To configure the backend, we use vault write to a _special path_ awes/config/root
```
vault write aws/config/root \
	accesss_key=foo \
	secret_key=bar
```
Remember that secret backends can behave anyway they want when reading/writing a path, so this path stores this configuration for later.
Notice that you can't read it back:
```
vault read aws/config/root
Error reading aws/config/root: Error making API request

URL: GET http://127.0.0.1:8200/v1/aws/config/root
Code: 405. Errors:

* unsupported operation
```
To help keep the credentials secure, the AWES backend doesn't let you read them back even if you are reading a root credential.
See: https://www.vaultproject.io/intro/getting-started/dynamic-secrets.html
for how to create a role. 

To generate a secret 
```
vault read aws/creds/deploy
```

```
Key             Value
---             -----
lease_id        aws/creds/deploy/0d042c53-aa8a-7ce7-9dfd-310351c465e5
lease_duration  768h0m0s
lease_renewable true
access_key      AKIAJFN42DVCQWDHQYHQ
secret_key      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
security_token  <nil>
```
The access and secret key can now be used to perform any EC2 operation within AWS. 
The lease_id above is a special ID used for Vault for renewal, revocation, etc. Copy and save your Lease ID now.

To revoce the secret:
Once the secret is revoked, the access keys will no longer work
To revoke the secret, use vault revoke with the lease ID that was outputted from vault read when you ran it:
```
vault revoke  aws/creds/deploy/0d042c53-aa8a-7ce7-9dfd-310351c465e5
```

#### Authentication
Authentication is the mechanism of assigning an identity to a Vault user.
The access control and permissions associated with an identiy are authorization(see next)

When you start a server with `vault server -dev`, it outputs your `root token`. The root token is the initial access token to
configure Vault. It has root priviliges, so it can perform any op. within Vault. 

To create more tokens, use `vault token-create`

```
Key             Value
token           c2c2fbd5-2893-b385-6fa5-30050439f698
token_accessor  0c1c3317-3d58-17e5-c1a9-3f54fa26610e
token_duration  0
token_renewable true
token_policies  [root]
```
By default, this will create a child token of your current token that inherits all the same policies.
The child concept here is important: tokens have a parent, and when that parent is revoked, children can also be revoked all in one operation.
This makes it easy when removing access for a user, to remove access for all sub-tokens that the user created as well.

To revoke a token:
```
$ vault token-revoke c2c2fbd5-2893-b385-6fa5-30050439f698
Success! Token revoked if it existed.
```
(vault revoke is used for revoking secrets, voke token-revoke is used for revoking tokens)

To authenticate with a token
```
$ vault auth d08e2bd5-ffb0-440d-6486-b8f650ec8c0c
Successfully authenticated! The policies that are associated
with this token are listed below:

root
```
This authenticates with Vault. It will verify your token and let you know what access policies the token is associated with.


In addition to tokens, other authentication, or auth, backends can be enabled.
Auth backends enable alternate methods of identifying with Vault. These identities are tied back to a set of access policies, just like tokens.
For example, for desktop environments, private key or GitHub based auth. is available. For server environments, some shared secret may be best.
They give you flexibility to choose what auth you want to use.

You can mount backends, and configure them like so
vault write auth/github/config organization=hashiborp
vault write auth/github/map/teams/default value=default

and you can then use
```
$ vault auth -method=github token=e6919b17dd654f2b64e67b6369d61cddc0bcc7d5
Successfully authenticated! The policies that are associated
with this token are listed below:

default
```

Yu can revoke like so
```
$ vault token-revoke -mode=path auth/github
```




#### Authorization
Policies in Vault control what a user can access.
For authorization and policies, Vault always uses the same format. All auth backends must map identities back to the core policies that are configured with Vault.
When initializing Vault, there is always one special policy created that can't be removed: the root policy.
This is a special policy that gives superuser access to everything in Vault. An identity mapped to the root policy can do anything.

Policies are formatted with HCL.
````
path "secret/*" {
  capabilities = ["create"]
}

path "secret/foo" {
  capabilities = ["read"]
}

path "auth/token/lookup-self" {
  capabilities = ["read"]
}
```

The policy format uses a prefix matching system on the API path to determine access control.
The most specific defined policy is used, either an exact match or the longest-prefix glob match.
Since everything in Vault must be accessed via the API, this gives strict control over every aspect of Vault, including mounting backends, authenticating, as well as secret access.

In the policy above, a user could any secret to secret/, except to secret/foo, where only read access is allowed. Policies default to deny, so any access to an unspecified path is not allowed.
To write a policy, use the policy-write command
```
$ vault policy-write secret acl.hcl
Policy 'secret' written.
```

to test apolicy, let's create a token and assign it to that policy. Make sure to save your root token somewhere so you can authenticate back to root user later.
```
$ vault token-create -policy="secret"
Key             Value
token           d97ef000-48cf-45d9-1907-3ea6ce298a29
token_accessor  71770cc5-14da-f0af-c6ce-17a0ae398d67
token_duration  2764800
token_renewable true
token_policies  [default secret]

$ vault auth d97ef000-48cf-45d9-1907-3ea6ce298a29
Successfully authenticated!
token: d97ef000-48cf-45d9-1907-3ea6ce298a29
token_duration: 2591938
token_policies: [default, secret]
```
You can now verify that you can write data to secret/, but only read from secret/foo:
```
$ vault write secret/bar value=yes
Success! Data written to: secret/bar

$ vault write secret/foo value=yes
Error writing data to secret/foo: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/secret/foo
Code: 403. Errors:

* permission denied
```
#### Mapping Policies to Auth Backends
Vault is the single policy authority, unlike auth where you can mount multiple backends.
Any mounted auth backend must map identities to these core policies.


#### HTTPS auth
Machines that need access to information stored in Vault will most likely access Vault via its REST API.
For example, if a machine were using AppRole for authentication, the application would first authenticate to Vault which would return a Vault API token.
The application would use that token for future communication with Vault.

After you have unlocked Vault like so
```
 curl \
    -X PUT \
    -d '{"key": "FwwsSzMysLgYAvJFrs+q5UfLMKIxC+dDFbP6YzyjzvQ="}' \
    http://127.0.0.1:8200/v1/sys/unseal
```
you can e.g use the root token to do whatever like so
```
curl -X POST -H "X-Vault-Token:$VAULT_TOKEN" -d '{"type":"approle"}' http://127.0.0.1:8200/v1/sys/auth/approle
``` 
Now we create an AppRole with desired set of ACL policies. 
Here we specify that the tokens issued under the AppRole testrole, should be associated with dev-policy and test-policy
```
curl -X POST -H "X-Vault-Token:$VAULT_TOKEN" -d '{"policies":"dev-policy,test-policy"}' http://127.0.0.1:8200/v1/auth/approle/role/testrole
```
The AppRole backend, in its default configuration, expects two hard to guess credentials, a role ID and a secret ID. This command fetches the role ID of the testrole
```
$ curl -X GET -H "X-Vault-Token:$VAULT_TOKEN" http://127.0.0.1:8200/v1/auth/approle/role/testrole/role-id | jq .
```
This command creates a new secret ID under the testrole
```
$ curl -X POST -H "X-Vault-Token:$VAULT_TOKEN" http://127.0.0.1:8200/v1/auth/approle/role/testrole/secret-id | jq .
```
See more: https://www.vaultproject.io/intro/getting-started/apis.html


#### Initialization
``
$ vault init
Key 1: 427cd2c310be3b84fe69372e683a790e01
Key 2: 0e2b8f3555b42a232f7ace6fe0e68eaf02
Key 3: 37837e5559b322d0585a6e411614695403
Key 4: 8dd72fd7d1af254de5f82d1270fd87ab04
Key 5: b47fdeb7dda82dbe92d88d3c860f605005
Initial Root Token: eaf5cc32-b48f-7785-5c94-90b5ce300e9b

Vault initialized with 5 keys and a key threshold of 3!
```
Initialization outputs two incredibly important pieces of information: the unseal keys and the initial root token. 
This is the only time ever that all of this data is known by Vault, and also the only time that the unseal keys should ever be so close together.

### Seal/Unseal
Every initialized Vault server starts in the sealed state. From the configuration, Vault can access the physical storage, but it can't read any of it because it doesn't know how to decrypt it. The process of teaching Vault how to decrypt the data is known as unsealing the Vault.

Unsealing has to happen every time Vault starts. It can be done via the API and via the command line. To unseal the Vault, you must have the threshold number of unseal keys. In the output above, notice that the "key threshold" is 3. This means that to unseal the Vault, you need 3 of the 5 keys that were generated.

```
$ vault unseal
Key (will be hidden):
Sealed: true
Key Shares: 5
Key Threshold: 3
Unseal Progress: 1
```














## Quotes
- "Key Valut streamlines the key management process and enables you to maintain control of keys that access and encrypt your data"



